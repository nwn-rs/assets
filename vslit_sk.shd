/*

vslit_sk.shd

*/

#define PI 3.14159265359

const int MAX_LIGHTS=8;
#define MAX_BONES 128

attribute vec4 vPos;
attribute vec2 vTcIn;
attribute vec3 vNormal;
attribute vec4 vIndex;
attribute vec4 vWeight;

uniform int idxmap[MAX_BONES];


uniform highp mat4 m_mvp;
uniform highp mat4 m_mv;
uniform highp mat3 m_normal;
uniform highp mat4 m_texture;
uniform highp mat4 m_bones[MAX_BONES];

uniform int fogEnabled;
uniform mediump float fogEnd;
uniform mediump float fogStart;

uniform lowp		vec4 lightAmbient			[MAX_LIGHTS];
uniform lowp		vec4 lightDiffuse			[MAX_LIGHTS];
uniform mediump		vec4 lightPosition			[MAX_LIGHTS];
uniform mediump		float lightQuadraticAtten	[MAX_LIGHTS];

uniform mediump	vec4  materialFrontAmbient;
uniform mediump	vec4  materialFrontDiffuse;
uniform mediump	vec4  materialFrontEmissive;

uniform lowp		vec4 frontLightModelProductSceneColor;

uniform int numLights;

varying vec2 vTc;
varying vec4 vColorOut;
varying float fFogFragCoord;
varying vec2 vTcEnv;

uniform highp mat4 m_m;

varying highp vec3 vWorldCoord;
varying highp vec4 viewPosition;

uniform int keyholeCanDissolve;

varying highp vec3 vKeyholeNoiseBase;

const float WORLD_COORDS_MOD_LIMIT = 35.0;

void SetKeyholeNoiseBase(vec4 vCoords)
{
    if(keyholeCanDissolve == 1)
    {
        highp mat4 tempM = m_m;
        tempM[3] = mod(tempM[3], WORLD_COORDS_MOD_LIMIT);
        vKeyholeNoiseBase = (tempM * vCoords).xyz;
    }
}


vec3 AmbientLight = vec3(0.0);
vec3 DiffuseLight = vec3(0.0);
//This type has no color attribute.
#define StaticLight vec4(0.0, 0.0, 0.0, 1.0)

// Often doesn't look good with vertex lighting, left here for experimenting.
#define SPECULAR_ENABLED 0

#if SPECULAR_ENABLED == 1
vec3 SpecularLight = vec3(0.0);
vec3 EyeToSurfaceNorm;
float fSpecularity = 0.1;
//uniform mediump vec4 materialFrontSpecular;
//uniform mediump float materialFrontShininess;
//float fShininess = materialFrontShininess;

float fSpecularity = 0.1;
float fShininess = 12.0;

//Using diffuse light for now.
//uniform lowp        vec4 lightSpecular          [MAX_LIGHTS];
#endif


void pointLight(in int i, in vec3 normal, in vec3 viewPosition)
{

    float fDotVP;       // normal . light direction
    float attenuation;  // computed attenuation factor
    float d;            // distance from surface to light source
    vec3 VP;           // direction from surface to light position

    // Compute vector from surface to light position
    VP = vec3(lightPosition[i]) - viewPosition;

    attenuation = 1.0;
    if(lightQuadraticAtten[i]>0.000000001) // Below is area lighting.
    {
        // Compute our squared distance between surface and light position
        d = dot(VP, VP);
        attenuation = 1.0 / (1.0 + lightQuadraticAtten[i] * d);
    }

    VP = normalize(VP);
    fDotVP = max(0.0, dot(normal, VP));

    if(fDotVP != 0.0)
    {
        DiffuseLight += lightDiffuse[i].rgb * fDotVP * attenuation;
        #if SPECULAR_ENABLED == 1
        vec3 HV = normalize(VP - EyeToSurfaceNorm);
        float fDotHV = max(0.0, dot(normal, HV));
        //Latter is for energy-conservation. Monte Carlo based as (n+2)/(2pi)
        float fSpecularIntensity = pow(fDotHV, fShininess) * (fShininess * 0.5 / PI + 1.0 / PI );
        SpecularLight += min(fDotVP*4.0, 1.0) * lightDiffuse[i].rgb * fSpecularIntensity * attenuation;
        //Using diffuse light element rather than specular until properly set up.
        //SpecularLight += min(fDotVP*4.0, 1.0) * lightSpecular[i].rgb * fSpecularIntensity * attenuation;
        #endif
    }
    AmbientLight += lightAmbient[i].rgb * attenuation;
}

vec4 computeLighting(in vec3 normal, in vec3 viewPosition3, float alphaFade)
{
    vec4 color;

    #if SPECULAR_ENABLED == 1
    EyeToSurfaceNorm = normalize(viewPosition3);
    #endif

	AmbientLight = StaticLight.rgb;
	

    for (int i = 0; i < numLights; i++) {
        pointLight(i, normal, viewPosition3);
    }

    color.rgb = 
                frontLightModelProductSceneColor.rgb +
                materialFrontEmissive.rgb +
                AmbientLight * materialFrontAmbient.rgb +
    #if SPECULAR_ENABLED == 1
                mix(DiffuseLight * materialFrontDiffuse.rgb, SpecularLight, fSpecularity);
    #else
                DiffuseLight * materialFrontDiffuse.rgb;
    #endif

    color.a = StaticLight.a * alphaFade * materialFrontDiffuse.a;


    // Clamp to reduce over-exposure.
    color = clamp(color, 0.0, 1.0);

    return color;
}

float ffog(in float viewDistance)
{
    //Make sure to not to clamp this in the vertex stage as we need to be able to get within boundaries through interpolation.
    //Taking absolute value of distance is important for some GUI elements.
    return (fogEnabled == 0) ? 0.0 : (abs(viewDistance)-fogStart) / (fogEnd - fogStart);
}

vec3 fnormal(void)
{
    //Compute the normal
    vec3 normal = m_normal * vNormal;
    normal = normalize(normal);
    return normal;
}

vec2 fRotateTexCoord(vec2 vTexCoord)
{
	vec4 vTc4 = vec4(vTexCoord.x, vTexCoord.y, 0, 1);
	vTc4 = m_texture * vTc4;
	return vTc4.xy;
}

void main (void)
{
	vec3  transformedNormal;
	float alphaFade = 1.0;
	vec4 vSkinnedPos = vPos;
	vec3 vSkinnedNormal = vNormal;

	int index = idxmap[int(vIndex.x)];
	vSkinnedPos = (m_bones[index] * vPos) * vWeight.x;
	vSkinnedNormal = (mat3(m_bones[index]) * vNormal) * vWeight.x;
	index = idxmap[int(vIndex.y)];
	vSkinnedPos = (m_bones[index] * vPos) * vWeight.y + vSkinnedPos;
	vSkinnedNormal = (mat3(m_bones[index]) * vNormal) * vWeight.y + vSkinnedNormal;
	index = idxmap[int(vIndex.z)];
	vSkinnedPos = (m_bones[index] * vPos) * vWeight.z + vSkinnedPos;
	vSkinnedNormal = (mat3(m_bones[index]) * vNormal) * vWeight.z + vSkinnedNormal;
	index = idxmap[int(vIndex.w)];
	vSkinnedPos = (m_bones[index] * vPos) * vWeight.w + vSkinnedPos;
	vSkinnedNormal = (mat3(m_bones[index]) * vNormal) * vWeight.w + vSkinnedNormal;

    // Eye-coordinate position of vertex, needed in various calculations
    viewPosition = m_mv * vSkinnedPos;
    //SetKeyholeNoiseBase(vPos.xyz);

    SetKeyholeNoiseBase(vSkinnedPos);
    vWorldCoord = (m_m * vSkinnedPos).xyz;

	// Do fixed functionality vertex transform
	gl_Position = m_mvp * vec4(vSkinnedPos.xyz, 1.0);
	//transformedNormal = fnormal();

	vSkinnedNormal = normalize(vSkinnedNormal);
	transformedNormal = m_normal * vSkinnedNormal;

	vColorOut = computeLighting(transformedNormal, viewPosition.xyz, alphaFade);

	fFogFragCoord = ffog(viewPosition.z);

	vTc = fRotateTexCoord(vTcIn);

    // Sphere mapping coord
    vec3 vEnvReflect = reflect(normalize(viewPosition.xyz), transformedNormal);
    vEnvReflect.z+=1.0;
    float fOffset= inversesqrt(dot(vEnvReflect, vEnvReflect));
    vTcEnv = 0.5 * vEnvReflect.xy * fOffset + 0.5;
}