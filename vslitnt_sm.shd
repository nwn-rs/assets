/*

vslitnt_sm.shd

*/

const int MAX_LIGHTS = 8;

attribute vec4 vPos;
attribute vec3 vNormal;

uniform highp mat4 m_mvp;
uniform highp mat4 m_mv;
uniform highp mat3 m_normal;

uniform int fogEnabled;
uniform mediump float fogEnd;
uniform mediump float fogStart;

uniform lowp		vec4 lightAmbient[MAX_LIGHTS];
uniform lowp		vec4 lightDiffuse[MAX_LIGHTS];
uniform mediump		vec4 lightPosition[MAX_LIGHTS];
uniform mediump		float lightQuadraticAtten[MAX_LIGHTS];

uniform mediump	vec4  materialFrontAmbient;
uniform mediump	vec4  materialFrontDiffuse;
uniform mediump	vec4  materialFrontEmissive;

uniform lowp		vec4 frontLightModelProductSceneColor;

uniform int numLights;

varying vec4 vColorOut;
varying float fFogFragCoord;
varying vec2 vTcEnv;

vec3 AmbientLight = vec3(0.0);
vec3 DiffuseLight = vec3(0.0);
//This type has no color attribute.
#define StaticLight vec4(0.0, 0.0, 0.0, 1.0)
// Generally doesn't look good with vertex lighting, left here for experimenting.
#define SPECULAR_ENABLED 0

#if SPECULAR_ENABLED == 1
vec3 SpecularLight = vec3(0.0);
vec3 EyeToSurfaceNorm;
float fSpecularity = 0.1;
uniform mediump vec4  materialFrontSpecular;
uniform mediump float materialFrontShininess;
//float fShininess = materialFrontShininess;
const float fShininess = 15.0;
//Using diffuse light for now.
//uniform lowp        vec4 lightSpecular          [MAX_LIGHTS];
#endif

void pointLight(in int i, in vec3 normal, in vec3 viewPosition)
{

    float fDotVP;       // normal . light direction
    float attenuation;  // computed attenuation factor
    float d;            // distance from surface to light source
    vec3 VP;           // direction from surface to light position

    // Compute vector from surface to light position
    VP = vec3(lightPosition[i]) - viewPosition;

    attenuation = 1.0;
    if(lightQuadraticAtten[i]>0.000000001) // Below is area lighting.
    {
        // Compute our squared distance between surface and light position
        d = dot(VP, VP);
        attenuation = 1.0 / (1.0 + lightQuadraticAtten[i] * d);
    }

    VP = normalize(VP);
    fDotVP = max(0.0, dot(normal, VP));

    if(fDotVP != 0.0)
    {
        DiffuseLight += lightDiffuse[i].rgb * fDotVP * attenuation;
        #if SPECULAR_ENABLED == 1
        vec3 HV = normalize(VP - EyeToSurfaceNorm);
        float fDotHV = max(0.0, dot(normal, HV));
        //Latter is for energy-conservation. Monte Carlo based as (n+2)/(2pi)
        float fSpecularIntensity = pow(fDotHV, fShininess) * (fShininess * 0.5 / PI + 1.0 / PI );
        SpecularLight += min(fDotVP*4.0, 1.0) * lightDiffuse[i].rgb * fSpecularIntensity * attenuation;
        //Using diffuse light element rather than specular until properly set up.
        //SpecularLight += min(fDotVP*4.0, 1.0) * lightSpecular[i].rgb * fSpecularIntensity * attenuation;
        #endif
    }
    AmbientLight += lightAmbient[i].rgb * attenuation;
}

vec4 flight(in vec3 normal, in vec3 viewPosition3, float alphaFade)
{
    vec4 color;

    #if SPECULAR_ENABLED == 1
    SpecularLight = vec3(0.0);
    EyeToSurfaceNorm = normalize(viewPosition3);
    #endif

	AmbientLight = StaticLight.rgb;
	
    for (int i = 0; i < numLights; i++) {
        pointLight(i, normal, viewPosition3);
    }


    color.rgb = 
                frontLightModelProductSceneColor.rgb +
                materialFrontEmissive.rgb +
                AmbientLight * materialFrontAmbient.rgb +
    #if SPECULAR_ENABLED == 1
                mix(DiffuseLight * materialFrontDiffuse.rgb, SpecularLight, fSpecularity);
    #else
                DiffuseLight * materialFrontDiffuse.rgb;
    #endif

    color.a = StaticLight.a * alphaFade * materialFrontDiffuse.a;
    color = clamp(color, 0.0, 1.0);
    return color;
}

float ffog(in float viewDistance)
{
    //Make sure to not to clamp this in the vertex stage as we need to be able to get within boundaries through interpolation.
    //Taking absolute value of distance is important for some GUI elements.
    return (fogEnabled == 0) ? 0.0 : (abs(viewDistance)-fogStart) / (fogEnd - fogStart);
}

vec3 fnormal(void)
{
    //Compute the normal
    vec3 normal = m_normal * vNormal;
    normal = normalize(normal);
    return normal;
}


void main(void)
{
    vec3  transformedNormal;
    float alphaFade = 1.0;

    // Eye-coordinate position of vertex, needed in various calculations
    vec4 viewPosition = m_mv * vPos;

    // Do fixed functionality vertex transform
    gl_Position = m_mvp * vPos;
    transformedNormal = fnormal();
    vColorOut = flight(transformedNormal, viewPosition.xyz, alphaFade);

    fFogFragCoord = ffog(viewPosition.z);
    // Sphere mapping coord
    vec3 vEnvReflect = reflect(normalize(viewPosition.xyz), transformedNormal);
    vEnvReflect.z+=1.0;
    float fOffset= inversesqrt(dot(vEnvReflect, vEnvReflect));
    vTcEnv = 0.5 * vEnvReflect.xy * fOffset + 0.5;
}