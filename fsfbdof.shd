//----------------------------------------
//Depth of Field shader.
//
//Version 1.01
//
//By Søren Møller (Zarathustra217)
//soerenpm@gmail.com
//
//----------------------------------------
//Description:
//
//Blurs the image based on distance to focus.
//
//Version history:
//
//1.0:
// - Initial release
//
//1.01:
// - Minor improvements to the blur algorithm.

const float fDOFWidth = 5.0; // Pixel distance of blur. Scales to resolution.
const float fDOFModifier = 0.07; // Modifier to blur.
const float fDOFMinDistance = 5.0; // Minimum distance for focus.
const float fDOFMaxDistance = 60.0; // Maximum distance for focus. Also sets the maximum distance of a pixel.
const float fDOFFocusOffset = 1.5; // Offset of focus in front of target (meters).

const float fPi= 3.14159;

varying mediump vec2 vTcOut;

uniform sampler2D texUnit0; // Frame buffer
uniform sampler2D texUnit1; // Depth buffer

uniform float nearClip = 0.1;
uniform float farClip = 45.0; // Normally this is fogEnd, but if there's a skybox it'll be further away.
uniform int screenWidth = 1920;
uniform int screenHeight = 1080;

float fResolutionModifier = float(screenHeight) / 1080.0;
vec2 vPixelSize = vec2(1.0/float(screenWidth), 1.0/float(screenHeight));

float Random(vec2 vCoords)
{
    return fract(sin(dot(vCoords, vec2(12.9898, 78.233))) * 43758.5453);
}

float fDepthModifier = 1.0 - nearClip/farClip;

float GetDepth(vec2 vCoords)
{
    vCoords = clamp(vCoords, 0.0, 1.0);
    float fDepth = texture2D(texUnit1, vCoords).x;
    fDepth = nearClip / (1.0 - fDepth*fDepthModifier);
    return fDepth;
}

float GetPixelConfusion(float fDepth, float fFocusDepth, float fFocusDepthModifier) 
{
    float fDepthDelta = fDepth - fFocusDepth;
    fDepthDelta*= fDOFModifier * fFocusDepthModifier;
    return min(1.0, abs(fDepthDelta));
}

vec4 DOF(vec4 vColor) 
{
    float fRandom = Random(vTcOut) * 0.333333 * fPi;
    vec2 vRandomX = vec2 (cos(fRandom), sin(fRandom)) * fDOFWidth * fResolutionModifier;
    vec2 vRandomY = vRandomX.yx;
    vRandomX.y = -vRandomX.y;
    vRandomX*=vPixelSize.x;
    vRandomY*=vPixelSize.y;
    float fDepth = GetDepth(vTcOut);
    float fDepthTolerance = 0.9 * fDepth; 
    float fCameraDistance = min(GetDepth(vec2(0.5, 0.45)), fDOFMaxDistance);
    float fCameraDistanceModifier = fDOFMinDistance / fCameraDistance;

    float fVerticalOffset = 0.14 * fCameraDistanceModifier;
    float fHorizontalOffset = 0.01 * fCameraDistanceModifier;

    float fFocusDepthU = GetDepth(vec2(0.49, 0.535) + vec2(-fHorizontalOffset, fVerticalOffset));
    float fFocusDepthL = GetDepth(vec2(0.5, 0.535) + vec2(0, fVerticalOffset));
    float fFocusDepthR = GetDepth(vec2(0.51, 0.535) + vec2(fHorizontalOffset, fVerticalOffset));
    float fFocusDepth = max(max(min(fFocusDepthL, fFocusDepthR), fFocusDepthU), fCameraDistance)-fDOFFocusOffset;
    fFocusDepth = clamp(fFocusDepth, fDOFMinDistance, fDOFMaxDistance);
    float fFocusDepthModifier = fDOFMinDistance / fFocusDepth;
    float fConfusionTolerance = 0.25 / (fDOFWidth * fResolutionModifier); //Minimum required to move to a new pixel.



    //Hexagon bokeh.
    vec2 vHalf0 = vec2( 0.500, 0.000);
    vHalf0 = vec2(dot(vHalf0, vRandomX), dot(vHalf0, vRandomY));
    vec2 vHalf60 = vec2( 0.250, 0.433);
    vHalf60 = vec2(dot(vHalf60, vRandomX), dot(vHalf60, vRandomY));
    vec2 vHalf120 = vec2( -0.250, 0.433);
    vHalf120 = vec2(dot(vHalf120, vRandomX), dot(vHalf120, vRandomY));
    vec2 vFull30 = vHalf0 + vHalf60;
    vec2 vFull90 = vHalf60 + vHalf120;
    vec2 vFull150 = vHalf120 - vHalf0;
    
    vec2 focal_blur[12];
    focal_blur[0]  = vHalf0;
    focal_blur[1]  = vHalf60;
    focal_blur[2]  = vHalf120;
    focal_blur[3]  = -vHalf0;
    focal_blur[4]  = -vHalf60;
    focal_blur[5]  = -vHalf120;
    focal_blur[6]  = vFull30;
    focal_blur[7]  = vFull90;
    focal_blur[8]  = vFull150;
    focal_blur[9]  = -vFull30;
    focal_blur[10] = -vFull90;
    focal_blur[11] = -vFull150;


    float fConfusionThis = GetPixelConfusion(fDepth, fFocusDepth, fFocusDepthModifier);
    int nBlurCount = 1;
    for (int i = 0; i < 12; i++) 
    {
        vec2 vOffset = focal_blur[i];
        float fBlurDepth = min(GetDepth(vTcOut + vOffset), fDOFMaxDistance);
        float fConfusion = fConfusionThis;
        // Only blur from other objects that are closer to us (with some tolerance). Otherwise we just use our own confusion to blur.
        if(fBlurDepth<fDepthTolerance) 
        {
            fConfusion=GetPixelConfusion(fBlurDepth, fFocusDepth, fFocusDepthModifier);
        }
        if(fConfusion>fConfusionTolerance)
        {
            vOffset *= fConfusion;
            if(any(greaterThanEqual(abs(vOffset), 0.5 * vPixelSize))) //Unless we move to a new pixel, there's really no point.
            {
                nBlurCount++;
                vColor += texture2D(texUnit0, vTcOut + vOffset);
            }
        }
    }
    return vColor / float(nBlurCount);
}


void main()
{
    vec4 vColor = texture2D(texUnit0, vTcOut);
    float fAlpha = vColor.a;
    vColor = DOF(vColor);
    vColor.a = fAlpha; // This should always be preserved as other shaders might need it.
    gl_FragColor = vColor;
}
